## 含多个对象的多重继承：

### 内存模型：

一个类中可能有某个基类的多个对象，例如：

```
class L{...};
class A : L{...};
class B : L{...};
class C : A, B{...};
```

这里对象C中会包含两个对象L，一个属于对象A，一个属于对象B

```
----------------------
|	L part (of A)	|
|	--------------	|
|	A part			|
----------------------
|	L part (of B)	|
|	--------------	|
|	B part			|
----------------------
|	C part			|
----------------------
```

### 名称：

如果类L中含有成员m，当`C::f()`需要调用`L::m`时，通过显示指定命名空间来选择调用哪一个L中的m，例如

```c++
void C::f(){A::m;}		//调用A中L的m
void C::f(){A::L::m;}	//更加详细地指定命名空间
```

### 类型转换：

当需要在`L*`和`C*`间类型转换时，需要注意避免二义性，考虑之前的例子：

```c++
C* pc = new C;
//C* to L*
L* pl = pc;				//error: ambiguous
pl = (L*)pc;			//error: still ambiguous
pl = (L*)(A*)pc;		//The L in C's A
//L* to C*
pc = pl;				//error: ambiguous
pc = (C*)pl;			//error: still ambiguous
pc = (C*)(A*)pl;		//The C containing A's L
```

当函数形参为`L*`时，可能会出一些问题，需要显示的转换消除二义性，例如：

```c++
void f(L*);
A a;
C c;
f(&a);		//fine
f(&c);		//error: ambiguous
f((A*)&c);	//fine
```

## 虚继承：

### 基本性质

当派生类中含有相同的多个基类对象时，如果这些基类对象相互独立，我们称之为独立多重继承。但是，出于语义考虑，很多时候仅需要最终派生类中仅实例化一个该基类对象。此时，这种基类在继承时需要被指定为`virtual`。

```c++
class AW : virtual W{...};
class BW : virtual W{...};
class CW : AW, BW{...};
```

此时，在类`CW`中的`AW`和`BW`会共享一个基类`W`。

类`W`的“virtualness”只是继承`W`的类（`AW`，`BW`）的一种性质，而不是`W`本身的性质。每一个"virtual"的基类在继承有向图(inheritance DAG)中只生成一个对象。

一个类可以同时拥有普通基类和虚拟基类，如下面这个例子，类D含有了两个L对象。

```c++
class A : virtual L{...};
class B : virtual L{...};
class C : A, B{...};
class D : L, C{...};
```

### 内存模型

一个虚继承的基类对象`W`是不能存放在相对于`AW`和`BW`有固定偏移地址的内存中的。相对应的，所有对象中应该存储指向`W`对象的指针，从而保证访问的独立性，例如：

```c++
AW* paw = new AW;
BW* pbw = new BW;
CW* pcw = new CW;
```

```
		-------------
paw-->	|	wptr	..........
		|	AW part	|		.
		|			|		.
		-------------		.
		|			|<.......
		|	W part	|
		|			|
		-------------
		
		-------------
pbw-->	|	wptr	..........
		|	BW part	|		.
		|			|		.
		-------------		.
		|			|<......
		|	W part	|
		|			|
		-------------
		
		-------------
pcw-->	|	wptr	..........
		|	AW part	|		.
		|			|		.
		-------------		.
		|			.........
		|	BW part	|		.
		|			|		.
		-------------		.
		|			|		.
		|	CW part	|		.
		|			|		.
		-------------		.
		|			|<.......
		|	W part	|
		|			|
		-------------
```

一个类可以拥有任意多含虚继承的基类。

从派生类类型转化为虚继承的基类是可行的，但是从虚继承的基类转化为派生类则不可行。前者只需要知道该基类的指针即可，而后者无法通过运行时已知的信息推断出基类如何。在基类中存储一个"back-pointer"(即指向派生类的指针)是非常复杂并不合适的机制。


## 虚多继承的优点和缺点

### 虚多继承的缺点
虚多继承的不足之处主要体现在两个方面：初始化构造和赋值
考虑如下的类结构：
```
class Base{...}
class X:public virtual Base{...};
class Y:public virtual Base{...};
class XY:public X, public Y {...};
```
首先重新解释一下多继承和许多继承的内存结构：
普通多继承
```
---------------------------------
| ----------------------------- |
| |  -----------------------  | |
| |  |		  Base   	   |  | |
| |  -----------------------  | |
| |						      | |
| |	     X's own members      | |
| ----------------------------- |
|-------------------------------|
| ----------------------------- |
| |  -----------------------  | |
| |  |		  Base   	   |  | |
| |  -----------------------  | |
| |						      | |
| |	     Y's own members      | |
| ----------------------------- |
|								|
|		XY's own members		|
|								|
---------------------------------
```
虚多继承
```
---------------------------------
| ----------------------------- |
| |  -----------------------  | |
| |  |		        	   |---------
| |  -----------------------  | |   |
| |						      | |   |
| |	     X's own members      | |	|
| ----------------------------- |	|
|-------------------------------|	|
| ----------------------------- |	|
| |  -----------------------  | |	|
| |  |		        	   |--------|
| |  -----------------------  | |	|
| |						      | |	|
| |	     Y's own members      | |	|
| ----------------------------- |	|
|		XY's own members		|	|
|								|	|
|   ------------------------    |	|
|	|		  Base		   |<--------			
|   ------------------------    |
---------------------------------
```
在虚多继承中，基类的初始化任务由XY的构造函数来完成，X和Y的构造函数完全不起作用。这可以用上面的类在内存中的结构来解释，因为只有XY的对象知道Base的数据所在偏移地址，X和Y只有指向该地址的指针，所以Base的初始化工作也只能由XY来完成。（通常共同基类的数据区会放在成员末尾，这取决于编译器）。XY的初始化器先初始化Base区域，之后调用直接基类的初始化器初始化剩余部分。
如果对于下面的初始化器：
```
X::X(int A) : Base(A) {}
Y::Y(int A) : Base(A) {}
XY::XY() : X(3), Y(6) {}
```
结论是Base既不会被初始化成3，也不会被初始化成6，因为在调用X,Y的初始化器前，XY对Base部分进行了默认初始化，之后的X,Y的初始化器均无效。
### 对于赋值
如果我们直接用编译器默认的赋值运算符对Base进行赋值，可能会对Base部分进行多次赋值，我部门将不知道Base部分会被拷贝多少次。如果我们希望实现自己的赋值运算符，比如
```
XY &XY::operator=(const XY& src){
	if(this != & src){
		X::operator=(*this);
		Y::operator=(*this);
		....
	}
	return *this;
}
```
上述代码将导致Base对象的重复赋值，要避免上述情况我们只能添加额外的函数到X和Y的类中来避免对Base成员的重复拷贝。修改后的代码如下：
```
XY &XY::operator=(const XY&src)
{
	if(this != &src){
		Base::operator  = (*this);
		X::PartialAssign(*this);
		Y::PartialAssign(*this);
		....
	}
	return *this;
}
```
### 动态类型转换
由于虚多继承类在内存中的分布，我们不能自己实现类型转换
```
Base *b = Get();
XY *q  =static_cast<XY*> (b);		//编译错误
XY*w = (XY*) (b);		//编译错误
```
编译器不报错实现方式应该是
```
XY *e = reinterpret_cast<XY* > (b);
```
然而这个结果并没有什么实际意义。因为reinterpre_cast并没有进行地址的偏移，将Base区域的地址视作XY对象的起始地址并不能正确地引用相应的对象。
正确的实现方式是使用dynamic_cast，但是dynamic_cast运行速度太慢而且容易出bug。

## 关于虚多继承的优点
首先虚继承并不是缺一不可的语言特性，因为对于很多没有虚继承的语言仍然能够运作得很好。并且如果对于某种类的设计，必需用到多继承，说明这种类的架构设计得并不好，我们没必要设计非常复杂的依赖关系像一棵错综复杂的树那样，我们呢完全可以设计出一片简洁的森林。

是否有某种场合使用多继承既方便又安全呢？Mix-ins。一个mix-in的类是不包含任何数据的，所有它的成员函数通常都是纯虚函数。它没有构造器(即使有也什么也不做）。所以，这意味着当拷贝这些成员对象时，不会带来问题。
如果基类是mix-in类，赋值操作是不危险的，即使一个对象呗拷贝多次，也没有关系，因为程序在编译完之后就会将其释放。























