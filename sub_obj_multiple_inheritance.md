## 含多个对象的多重继承：

### 内存模型：

一个类中可能有某个基类的多个对象，例如：

```
class L{...};
class A : L{...};
class B : L{...};
class C : A, B{...};
```

这里对象C中会包含两个对象L，一个属于对象A，一个属于对象B

```
----------------------
|	L part (of A)	|
|	--------------	|
|	A part			|
----------------------
|	L part (of B)	|
|	--------------	|
|	B part			|
----------------------
|	C part			|
----------------------
```

### 名称：

如果类L中含有成员m，当`C::f()`需要调用`L::m`时，通过显示指定命名空间来选择调用哪一个L中的m，例如

```c++
void C::f(){A::m;}		//调用A中L的m
void C::f(){A::L::m;}	//更加详细地指定命名空间
```

### 类型转换：

当需要在`L*`和`C*`间类型转换时，需要注意避免二义性，考虑之前的例子：

```c++
C* pc = new C;
//C* to L*
L* pl = pc;				//error: ambiguous
pl = (L*)pc;			//error: still ambiguous
pl = (L*)(A*)pc;		//The L in C's A
//L* to C*
pc = pl;				//error: ambiguous
pc = (C*)pl;			//error: still ambiguous
pc = (C*)(A*)pl;		//The C containing A's L
```

当函数形参为`L*`时，可能会出一些问题，需要显示的转换消除二义性，例如：

```c++
void f(L*);
A a;
C c;
f(&a);		//fine
f(&c);		//error: ambiguous
f((A*)&c);	//fine
```

## 虚继承：

### 基本性质

当派生类中含有相同的多个基类对象时，如果这些基类对象相互独立，我们称之为独立多重继承。但是，出于语义考虑，很多时候仅需要最终派生类中仅实例化一个该基类对象。此时，这种基类在继承时需要被指定为`virtual`。

```c++
class AW : virtual W{...};
class BW : virtual W{...};
class CW : AW, BW{...};
```

此时，在类`CW`中的`AW`和`BW`会共享一个基类`W`。

类`W`的“virtualness”只是继承`W`的类（`AW`，`BW`）的一种性质，而不是`W`本身的性质。每一个"virtual"的基类在继承有向图(inheritance DAG)中只生成一个对象。

一个类可以同时拥有普通基类和虚拟基类，如下面这个例子，类D含有了两个L对象。

```c++
class A : virtual L{...};
class B : virtual L{...};
class C : A, B{...};
class D : L, C{...};
```

### 内存模型

一个虚继承的基类对象`W`是不能存放在相对于`AW`和`BW`有固定偏移地址的内存中的。相对应的，所有对象中应该存储指向`W`对象的指针，从而保证访问的独立性，例如：

```c++
AW* paw = new AW;
BW* pbw = new BW;
CW* pcw = new CW;
```

```
		-------------
paw-->	|	wptr	..........
		|	AW part	|		.
		|			|		.
		-------------		.
		|			|<.......
		|	W part	|
		|			|
		-------------
		
		-------------
pbw-->	|	wptr	..........
		|	BW part	|		.
		|			|		.
		-------------		.
		|			|<......
		|	W part	|
		|			|
		-------------
		
		-------------
pcw-->	|	wptr	..........
		|	AW part	|		.
		|			|		.
		-------------		.
		|			.........
		|	BW part	|		.
		|			|		.
		-------------		.
		|			|		.
		|	CW part	|		.
		|			|		.
		-------------		.
		|			|<.......
		|	W part	|
		|			|
		-------------
```

一个类可以拥有任意多含虚继承的基类。

从派生类类型转化为虚继承的基类是可行的，但是从虚继承的基类转化为派生类则不可行。前者只需要知道该基类的指针即可，而后者无法通过运行时已知的信息推断出基类如何。在基类中存储一个"back-pointer"(即指向派生类的指针)是非常复杂并不合适的机制。