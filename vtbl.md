# 虚继承的实现
## 虚函数表
之前已经讲过虚函数的内存布局，而虚函数的实现机制是有虚函数表来实现的，简称vtbl。vtbl是一个类的虚函数的地址表，这张表解决了虚函数继承和覆盖的问题。同时实现了用基类的指针操纵派生类
假设有如下类：
```
class Base{
	public:
	virtual void f(){ cout << "Base::f" << endl;}
	virtual void g(){ cout << "Base :: g" << endl;}
	virtual void h(){ cout << "Base:: h" << endl;}
};
```
其在内存中为：
```
&b
-------------
|		----|----
-------------	|	  ----------------------------------------------------
|			|	|-----|Base::f() | Base::g() | Base::h() | terminal mark |
-------------		  ----------------------------------------------------
|			|
-------------

```
## 无虚函数覆盖的单继承
```
class Base{
	...
};
class Derived{
	virtual void f1(){};
	virtual void g1(){};
	virtual void h1(){};
}
derived b;
```
满足：
- 虚函数按照声明顺序放在链表中
- 基类的虚函数放在派生类的前面
如下：
```
&b
-------------
|		----|----
-------------	|	  ----------------------------------------------------------------------------------------------------
|			|	|-----|Base::f() | Base::g() | Base::h() | Derived::f1() | Derived::g1() | Derived::h1() | terminal mark |
-------------		  ----------------------------------------------------------------------------------------------------
|			|
-------------

```

## 有虚函数覆盖的继承
满足的原则是：
- 派生类的函数指针覆盖了基类函数指针的位置
- 没有被覆盖的函数指针不变
比如
```
class Base{...};
class Derived{
	virtual void f(){};
}
```

布局：
```
&b
-------------
|		----|----
-------------	|	  ----------------------------------------------------------------------------------------------------
|			|	|-----|Derived::f() | Base::g() | Base::h() | Derived::f1() | Derived::g1() | Derived::h1() | terminal mark |
-------------		  ----------------------------------------------------------------------------------------------------
|			|
-------------

```
## 多重继承(无虚函数覆盖)
原则是：
- 派生类的函数只放在第一个基类的链表中，且按照函数声明的顺序，派生类的成员放在基类的成员之后
- 非第一个基类的链表只放置自己的成员
- 兼容了单继承的做法
以派生类Derive继承Base1,Base2,Base3为例
```
class Base1{
	virtual void f(){};
	virtual void g(){};
	virtual void g(){};
};

class Base2{
	virtual void f(){};
	virtual void g(){};
	virtual void g(){};	
};

class Base3{
	virtual void f(){};
	virtual void g(){};
	virtual void h(){};
};

class Derived{
	virtual void f1(){};
	virtual void g1(){};
};
```
内存布局：
```
&b
-------------         --------------------------------------------------------------------------------------
|		----|---------|Base1::f() | Base1::g() | Base1::h() | Derived::f1() | Derived::g1() |terminal mark |
-------------		  --------------------------------------------------------------------------------------
|			|         ------------------------------------------------------
|		--------------|Base2::f() | Base2::g() | Base2::h() |terminal mark |
|			|	      ------------------------------------------------------
-------------		  ------------------------------------------------------
|		--------------|Base3::f() | Base3::g() | Base3::h() |terminal mark |
------------- 		  ------------------------------------------------------

```
## 多重继承（派生类覆盖基类）
原则是：
- 派生类函数指针同时覆盖基类的对应函数位置。
- 未覆盖的派生类独有的成员虚函数仍放置在第一个虚函数表的末尾
示例代码如下
```
class Base1{
	virtual void f(){};
	virtual void g(){};
	virtual void g(){};
};

class Base2{
	virtual void f(){};
	virtual void g(){};
	virtual void g(){};	
};

class Base3{
	virtual void f(){};
	virtual void g(){};
	virtual void h(){};
};

class Derived{
	virtual void f(){};
	virtual void g1(){};
};

```
内存结构如下：
```
&b
-------------         ------------------------------------------------------------------------
|		----|---------|Derived::f() | Base1::g() | Base1::h() | Derived::g1() |terminal mark |
-------------		  ------------------------------------------------------------------------
|			|         ------------------------------------------------------
|		--------------|Derived::f() | Base2::g() | Base2::h() |terminal mark |
|			|	      ------------------------------------------------------
-------------		  ------------------------------------------------------
|		--------------|Derived::f() | Base3::g() | Base3::h() |terminal mark |
------------- 		  ------------------------------------------------------
```

## 安全性考量
1. 我们在之前提到过用基类的指针可以指向派生类对象的基类部分，但是无法操控派生类对象独有的部分，但是实际上通过指针可以对派生类对象的独有成员进行修改
2. 我们都知道对于private的虚函数无法通过派生类的对象访问，但是这些非public的虚函数仍然会被加入虚函数表中，我们仍然可以通过指针的方式来引用基类的private的虚函数
