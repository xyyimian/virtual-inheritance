# 虚多继承的优点和缺点





## 虚多继承的缺点
虚多继承的不足之处主要体现在两个方面：初始化构造和赋值
考虑如下的类结构：
```
class Base{...}
class X:public virtual Base{...};
class Y:public virtual Base{...};
class XY:public X, public Y {...};
```
首先重新解释一下多继承和许多继承的内存结构：
普通多继承
```
---------------------------------
| ----------------------------- |
| |  -----------------------  | |
| |  |		  Base   	   |  | |
| |  -----------------------  | |
| |						      | |
| |	     X's own members      | |
| ----------------------------- |
|-------------------------------|
| ----------------------------- |
| |  -----------------------  | |
| |  |		  Base   	   |  | |
| |  -----------------------  | |
| |						      | |
| |	     Y's own members      | |
| ----------------------------- |
|								|
|		XY's own members		|
|								|
---------------------------------
```
虚多继承
```
---------------------------------
| ----------------------------- |
| |  -----------------------  | |
| |  |		        	   |---------
| |  -----------------------  | |   |
| |						      | |   |
| |	     X's own members      | |	|
| ----------------------------- |	|
|-------------------------------|	|
| ----------------------------- |	|
| |  -----------------------  | |	|
| |  |		        	   |--------|
| |  -----------------------  | |	|
| |						      | |	|
| |	     Y's own members      | |	|
| ----------------------------- |	|
|		XY's own members		|	|
|								|	|
|   ------------------------    |	|
|	|		  Base		   |<--------			
|   ------------------------    |
---------------------------------
```
在虚多继承中，基类的初始化任务由XY的构造函数来完成，X和Y的构造函数完全不起作用。这可以用上面的类在内存中的结构来解释，因为只有XY的对象知道Base的数据所在偏移地址，X和Y只有指向该地址的指针，所以Base的初始化工作也只能由XY来完成。（通常共同基类的数据区会放在成员末尾，这取决于编译器）。XY的初始化器先初始化Base区域，之后调用直接基类的初始化器初始化剩余部分。
如果对于下面的初始化器：
```
X::X(int A) : Base(A) {}
Y::Y(int A) : Base(A) {}
XY::XY() : X(3), Y(6) {}
```
结论是Base既不会被初始化成3，也不会被初始化成6，因为在调用X,Y的初始化器前，XY对Base部分进行了默认初始化，之后的X,Y的初始化器均无效。
## 对于赋值
如果我们直接用编译器默认的赋值运算符对Base进行赋值，可能会对Base部分进行多次赋值，我部门将不知道Base部分会被拷贝多少次。如果我们希望实现自己的赋值运算符，比如
```
XY &XY::operator=(const XY& src){
	if(this != & src){
		X::operator=(*this);
		Y::operator=(*this);
		....
	}
	return *this;
}
```
上述代码将导致Base对象的重复赋值，要避免上述情况我们只能添加额外的函数到X和Y的类中来避免对Base成员的重复拷贝。修改后的代码如下：
```
XY &XY::operator=(const XY&src)
{
	if(this != &src){
		Base::operator  = (*this);
		X::PartialAssign(*this);
		Y::PartialAssign(*this);
		....
	}
	return *this;
}
```
## 动态类型转换
由于虚多继承类在内存中的分布，我们不能自己实现类型转换
```
Base *b = Get();
XY *q  =static_cast<XY*> (b);		//编译错误
XY*w = (XY*) (b);		//编译错误
```
编译器不报错实现方式应该是
```
XY *e = reinterpret_cast<XY* > (b);
```
然而这个结果并没有什么实际意义。因为reinterpre_cast并没有进行地址的偏移，将Base区域的地址视作XY对象的起始地址并不能正确地引用相应的对象。
正确的实现方式是使用dynamic_cast，但是dynamic_cast运行速度太慢而且容易出bug。

## 关于虚多继承的优点
首先虚继承并不是缺一不可的语言特性，因为对于很多没有虚继承的语言仍然能够运作得很好。并且如果对于某种类的设计，必需用到多继承，说明这种类的架构设计得并不好，我们没必要设计非常复杂的依赖关系像一棵错综复杂的树那样，我们呢完全可以设计出一片简洁的森林。

是否有某种场合使用多继承既方便又安全呢？Mix-ins。一个mix-in的类是不包含任何数据的，所有它的成员函数通常都是纯虚函数。它没有构造器(即使有也什么也不做）。所以，这意味着当拷贝这些成员对象时，不会带来问题。
如果基类是mix-in类，赋值操作是不危险的，即使一个对象呗拷贝多次，也没有关系，因为程序在编译完之后就会将其释放。

