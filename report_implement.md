## C++的多重继承实现机制

首先，我们先考虑C++的单重继承实现机制

一个C++的类的对象是由一块连续的内存存放，对象的指针即是这块连续内存的第一个字节的地址。

```c++
class A
{
  int a;
  void f(int i);
};
```

一个类的对象对应的内存仅存储了该类的非静态变量，例如class A的内存模型如下，该内存中并不包含类的(非虚)成员函数的相关信息

```
-------------
|	int a	|
-------------
```

在调用成员函数时，如

```c++
A* pa;
pa->f(2);
```

将会被编译器转化为一个普通函数的调用，但是要额外传入调用该成员函数的对象的指针，类似于

```
f__Af(pa, 2);
```

当类中出现了虚函数时，编译器将生成一个含所有虚函数信息的表，每个对象将存储该表的地址，例如

```c++
class A{
  	int a;
  	virtual void f(int);
  	virtual void g(int);
  	virtual void h(int);
};
class B:public A{int b; void g(int);}
class C:public B{int c; void h(int);}
```

class C的内存模型如下：

```
-------------
|	int a;	|
|	vptr	------------->vtbl:
|	int b;	|			-------------
|	int c;	|			|	A::f	|
-------------			|	B::g	|
						|	C::h	|
						-------------
```

调用一个虚函数时,

```c++
C* pc;
pc->g(2);
```

被编译器转化为类似于下面的操作:

```c++
(*(pc->vptr[1]))(pc, 2);
```







